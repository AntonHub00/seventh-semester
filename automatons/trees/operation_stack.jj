PARSER_BEGIN(SimpleExpression)

    import java.util.ArrayList;
    import java.util.Stack;
    import java.util.HashMap;

    public class SimpleExpression{

        static ArrayList<String> postfixList = new ArrayList<String>();
        static Stack<String> operatorsStack = new Stack<String>();
        static HashMap<String, Integer> operatorsValues = new HashMap<String, Integer>();

        /* To compare the operators precedence */
        static void initializeOperatorsValues(){
            operatorsValues.put("+", 0);
            operatorsValues.put("-", 0);
            operatorsValues.put("*", 1);
            operatorsValues.put("/", 1);
        }

        /* Add the remaining stack elements to the postfix list */
        static void flushStack(){
            while(!operatorsStack.isEmpty()){
                postfixList.add(operatorsStack.pop());
            };
        }

        /* This method just considers operators and parenthesis. Operands are */
        /* inserted directly in the semantic section */
        static void shuntingYard(String operator){
            if(operator == ")"){
                /* If the "operator" is ")", then pop all the stack elements till */
                /* reach "(". "(" and ")" are discarded */
                String stackTopOperator;
                do{
                    stackTopOperator = operatorsStack.pop();
                    if(stackTopOperator != "("){
                        postfixList.add(stackTopOperator);
                    }
                }while(stackTopOperator != "(");
            }
            else if(
                    operator == "(" ||
                    operatorsStack.isEmpty() ||
                    operatorsStack.peek() == "("
                   ){
                /* If either the "operator" is "(", the stack is empty or the stack top */
                /* element is "(" then push the "operator" onto the stack */
                operatorsStack.push(operator);
            }else if(
                    operatorsValues.get(operator) >
                    operatorsValues.get(operatorsStack.peek())){
                /* If the current "operator" precedence is higher than the stack top */
                /* element, then push the "operator" onto the stack */
                operatorsStack.push(operator);
            }else{
                int currentOperatorValue = operatorsValues.get(operator);
                int stackTopOperatorValue = operatorsValues.get(operatorsStack.peek());

                while(
                        currentOperatorValue < stackTopOperatorValue ||
                        currentOperatorValue == stackTopOperatorValue
                     ){

                    /* If the current "operator" precedence is lower or equals than */
                    /* the stack top element, then stack elements will be popped */
                    /* till the stack is empty or the stack top element is "(". Then */
                    /* the current operator will be pushed to the stack */

                    postfixList.add(operatorsStack.pop());

                    if(operatorsStack.isEmpty() || operatorsStack.peek() == "("){
                        break;
                    }

                    stackTopOperatorValue = operatorsValues.get(operatorsStack.peek());
                };

                operatorsStack.push(operator);
            }
        }

        public static void main(String[] args) throws ParseException {
            SimpleExpression analisis = new SimpleExpression(System.in);
            initializeOperatorsValues();
            analisis.start();
        }
    }

PARSER_END(SimpleExpression)

    SKIP: { " " | "\t" | "\n" | "\r"}

TOKEN:
{
    <variable: (["a"-"z"])+>
        |
        <constant: (["0"-"9"])+>
        |
        <addOperator: "+">
        |
        <subOperator: "-">
        |
        <mulOperator: "*">
        |
        <divOperator: "/">
        |
        <leftParen: "(">
        |
        <rightParen: ")">
}

void start() : {} {
    expression() <EOF>
    {
        flushStack();
        System.out.println();
        System.out.println("postfix list: " + postfixList);
    }
}

void expression(): {} {
    /* term() ((<addOperator> | <subOperator>) term())* */
    term() expression_prime()
}

void expression_prime(): {} {
    (<addOperator> {shuntingYard(token.image.toString());}
     |
     <subOperator> {shuntingYard(token.image.toString());}
    )
        term() expression_prime() | empty()
}

void term(): {} {
    /* factor() ((<mulOperator> | <divOperator>) factor())* */
    factor() term_prime()
}

void term_prime(): {} {
    (<mulOperator> {shuntingYard(token.image.toString());}
     |
     <divOperator> {shuntingYard(token.image.toString());}
    )
        factor() term_prime() | empty()
}

void factor(): {} {
    <constant> {postfixList.add(token.image.toString());}
    |
        <variable> {postfixList.add(token.image.toString());}
    |
        <leftParen> {shuntingYard(token.image.toString());}
    expression()
        <rightParen> {shuntingYard(token.image.toString());}
}

// Emulates epsilon
void empty(): {}
{
    {return;}
}
